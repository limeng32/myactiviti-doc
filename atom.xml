<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flying-doc</title>
  <link href="http://flying-doc.limeng32.com/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="http://flying-doc.limeng32.com" rel="alternate" type="text/html"/>
  <updated>2017-09-04T10:30:00+00:00</updated>
  <id>http://flying-doc.limeng32.com</id>
  <author>
    <name>limeng32</name>
    <email>limeng32@live.cn</email>
  </author>
  <entry>
    <title>flying-是什么</title>
    <link href="http://flying-doc.limeng32.com/flying-%E6%98%AF%E4%BB%80%E4%B9%88"/>
    <updated>2017-10-16T00:00:00+00:00</updated>
    <id>http://flying-doc.limeng32.com/flying-%E6%98%AF%E4%BB%80%E4%B9%88</id>
    <content type="html">
    <h2 id="为什么要开发-flying"><a href="#Index">为什么要开发 flying</a></h2>
<p>众所周知，Mybatis 在设计之初是作为一个工作于单线程之下的中间件而存在，虽然它易于上手，但放到互联网环境下使用时，初学者不可避免的要面对诸如“一级缓存存在脏数据”、“需要写大量明文 SQL 语句”等问题。这些是用户最关心的“是否可用”级别问题，也是 Mybatis-3 系列版本中开发团队并没有完全解决的问题，或者说，相对于另一个竞争产品 Hibernate，Mybatis 的开发团队选择了一种更谦逊的方式，他们开放 Mybatis 接口，允许用户开发插件，按自己的方式来解决这些问题。于是，一切 ORM 领域相关的问题在 Mybatis 上通过插件都有了解决方案。而本文所要介绍的 flying，则是集成了用户最需要的几个功能的插件组。与此同时 flying 提出了一种新的调用数据的方式，希望能对您起到抛砖引玉的作用。</p>

<h2 id="如何获取-flying"><a href="#Index">如何获取 flying</a></h2>

<p>目前 flying 已加入到 maven 中心库内，所以您只需在POM文件中加入依赖：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;groupId&gt;com.github.limeng32&lt;/groupId&gt;
&lt;artifactId&gt;mybatis.flying&lt;/artifactId&gt;
&lt;version&gt;0.9.0&lt;/version&gt;
</code></pre>
</div>
<p>即可以使用。mybatis 版本与 flying 最新版本的对应关系见下：</p>

<p>mybatis <code class="highlighter-rouge">3.2.6</code> <code class="highlighter-rouge">3.2.7</code> <code class="highlighter-rouge">3.2.8</code> 对应 flying <code class="highlighter-rouge">0.7.3</code></p>

<p>mybatis <code class="highlighter-rouge">3.3.0</code> <code class="highlighter-rouge">3.3.1</code> 对应 flying <code class="highlighter-rouge">0.8.1</code></p>

<p>mybatis <code class="highlighter-rouge">3.4.0</code> <code class="highlighter-rouge">3.4.1</code> <code class="highlighter-rouge">3.4.2</code> <code class="highlighter-rouge">3.4.3</code> <code class="highlighter-rouge">3.4.4</code> <code class="highlighter-rouge">3.4.5</code> 对应 <code class="highlighter-rouge">0.9.1</code></p>

<p>（目前 flying 不支持 mybatis-3.2.6 之前的版本）</p>

<p>考虑到您可能是以前版本 flying 的使用者，我们会在文档中用 <code class="highlighter-rouge">New</code> 将最新版本新增特性标识出来，在目录中用红色将新增章节标识出来。</p>

<p>如果您使用的是基于某一版本 mybatis 的定制版，您可以在依赖配置中加入 <code class="highlighter-rouge">exclusions</code>，以 mybatis-3.3.x 的定制版为例，您的依赖配置就像下面这样：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.limeng32&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis.flying&lt;/artifactId&gt;
    &lt;version&gt;0.8.1&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
</div>
<p>在您做好以上配置之后，flying 会自动下载到您的电脑本地。</p>

<h2 id="如何使用-flying"><a href="#Index">如何使用 flying</a></h2>

<p>使用本插件前您需要具备 Java 开发数据库应用的知识和使用 Mybatis 基本功能的经验。
在 Mybatis 中，有一个核心的配置文件，称做 Configuration.xml，我们的插件需要先在这里配置，才能在运行期被识别出来。</p>

<p>在 Configuration.xml 中，首先为了让 Mybatis 在多线程环境下工作的更好，需要在 <code class="highlighter-rouge">settings</code> 中进行以下设置：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;settings&gt;
    &lt;setting name="lazyLoadingEnabled" value="false" /&gt;
    &lt;setting name="aggressiveLazyLoading" value="false" /&gt;
    &lt;setting name="localCacheScope" value="SESSION" /&gt;
    &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;
    &lt;setting name="lazyLoadTriggerMethods" value="" /&gt;
&lt;/settings&gt;
</code></pre>
</div>
<p>（以上配置中没有提到的内容用户可按照自己的实际情况进行配置）</p>

<p>然后，在 Configuration.xml 的底部，我们加入 <code class="highlighter-rouge">plugins</code> 元素，将 flying 中的 Interceptor（拦截器）配置成 <code class="highlighter-rouge">plugin</code>，然后放到 <code class="highlighter-rouge">plugins</code> 中。目前 flying 有两个主要拦截器（负责处理 pojo 自动注射的 <code class="highlighter-rouge">AutoMapperInterceptor</code> 和负责完善二级缓存的 <code class="highlighter-rouge">EnhancedCachingInterceptor</code>），配置它们的方式如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;plugins&gt;
    &lt;plugin interceptor="indi.mybatis.flying.interceptors.AutoMapperInterceptor"&gt;
        &lt;property name="dialect" value="mysql" /&gt;
    &lt;/plugin&gt;
    &lt;plugin interceptor="indi.mybatis.flying.interceptors.EnhancedCachingInterceptor"&gt;
        &lt;property name="cacheEnabled" value="true" /&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
</div>
<p>（以上配置中 <code class="highlighter-rouge">dialect</code> 标识了目标数据库为 mysql，<code class="highlighter-rouge">cacheEnabled</code> 标识了二级缓存为打开状态，更多的属性请参见讲解该插件的章节。）</p>

<p>配置好以上内容之后，保存 Configuration.xml 文件，按正常方式启动 Mybatis，flying 即可生效。</p>

<p>flying采用非侵占式工作机制，您既可以在以传统方式使用 mybatis 的项目中加入一部分以 flying 方式配置的方法，也可以在以 flying 方式配置的项目中加入一部分传统方式的方法，当然更好的选择是，完全使用 flying 方式替代传统的方式。</p>

<h2 id="如何查看-flying-的源代码"><a href="#Index">如何查看 flying 的源代码</a></h2>

<p>flying 的代码在 github 上进行开源，访问地址为 <a href="https://github.com/limeng32/mybatis.flying">https://github.com/limeng32/mybatis.flying</a>，您可以在 github 上通过 Issues 与我们联系，提出您的需要，或是加入我们成为贡献者，提交您的代码，我们非常欢迎您这样做。</p>
    </content>
  </entry>
  <entry>
    <title>使用flying解决pojo自动映射问题</title>
    <link href="http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E8%A7%A3%E5%86%B3pojo%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98"/>
    <updated>2017-10-16T00:00:00+00:00</updated>
    <id>http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E8%A7%A3%E5%86%B3pojo%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98</id>
    <content type="html">
      <h2 id="hello-world"><a href="#Index">Hello World</a></h2>
<p>上一篇文章中我们介绍了 flying 的基本情况，在展示第一个 demo 之前还需要做一些额外的工作，即描述您想让 mybatis 管理的数据的表结构。</p>

<p>无论是否使用 flying 插件，对于每一个由 mybatis 托管的表，都要有一个 <i>pojo_mapper</i>.xml 来告诉 mybatis 这个表的基本信息。在以往这个配置文件可能会因为 sql 片段而变得非常复杂，但加入 flying 插件后，这个配置文件中将不需要 sql 片段，变得精简而统一。下面是 <a href="#AccountTableCreater">一个有代表性的 account 表</a> 以及对应它的配置文件 account.xml ：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="nt">&lt;mapper</span> <span class="na">namespace=</span><span class="s">"myPackage.AccountMapper"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;cache</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"select"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying#{?}:select
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectOne"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying:selectOne
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">"result"</span> <span class="na">type=</span><span class="s">"Account"</span> <span class="na">autoMapping=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;id</span> <span class="na">property=</span><span class="s">"id"</span> <span class="na">column=</span><span class="s">"account_id"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/resultMap&gt;</span>
<span class="nt">&lt;/mapper&gt;</span>
</code></pre>
</div>
<p>在以上配置文件中，我们描述了一个接口 myPackage.AccountMapper，一个方法 select ，一个方法 selectOne，一个对象实体 Account，以及数据库表结构 resultMap。在 resultMap 中由于设置了 <code class="highlighter-rouge">autoMapping="true"</code>，我们只需要写出主键（以及外键，在稍后的章节会讲到），mybatis 会自动感知与 Account.java 中对应的变量名相同的字段，但与变量名有差异的字段仍需在 resultMap 中声明。</p>

<p>myPackage.AccountMapper 接口是 mybatis 本身需要的，里面的内容和 account.xml 中定义的方法相对应。如果您有使用 mybatis 的经验您就能立刻想到， AccountMapper.java 中的内容是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
public interface AccountMapper {
    public Account select(Object id);
    public Account selectOne(Account t);
}
</code></pre>
</div>
<p>到目前为止一切都和不使用 flying 时一模一样，您可能奇怪的地方是：account.xml 中的 select 和 selectOne 方法描述中的 flying#{?}:select 是什么。这是这条查询的 flying 特征值描述，<a href="#why-no-sql">在 flying 特征值描述部分会有解释。</a>马上我们就会在对象实体 Account 中看到更多不一样的地方，Account.java 的代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import org.apache.ibatis.type.JdbcType;
import indi.mybatis.flying.annotations.FieldMapperAnnotation;
import indi.mybatis.flying.annotations.TableMapperAnnotation;
    
@TableMapperAnnotation(tableName = "account")
public class Account {
    @FieldMapperAnnotation(dbFieldName = "account_id", jdbcType = JdbcType.INTEGER, isUniqueKey = true)
    private Integer id;
	    
    @FieldMapperAnnotation(dbFieldName = "name", jdbcType = JdbcType.VARCHAR)
    private java.lang.String name;
	    
    public Integer getId() {
	    return id;
    }
    public void setId(Integer id) {
		this.id = id;
    }
    public String getName() {
		return name;
    }
    public void setName(String name) {
		this.name = name;
    }
}
</code></pre>
</div>
<p>可见，和普通的 pojo 相比， Account.java 只是多了以下3行注解而已：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@TableMapperAnnotation(tableName = "account")
@FieldMapperAnnotation(dbFieldName = "id", jdbcType = JdbcType.INTEGER, isUniqueKey = true)
@FieldMapperAnnotation(dbFieldName = "name", jdbcType = JdbcType.VARCHAR) 
</code></pre>
</div>
<p>下面我们分别来解释它们的含义。</p>

<p>第1行 <code class="highlighter-rouge">@TableMapperAnnotation</code> 只能放在类定义之上，它声明这个类是一个表，它的属性 <code class="highlighter-rouge">tableName</code> 描述了这个表在数据库中的名字。</p>

<p>第2行 <code class="highlighter-rouge">@FieldMapperAnnotation</code> 只能放在变量定义之上，它声明这个变量是一个字段，它的属性 <code class="highlighter-rouge">dbFieldName</code> 描述了在数据库中这个字段的名称，它的属性 <code class="highlighter-rouge">jdbcType</code> 描述了在数据库中这个字段的类型，它的属性 <code class="highlighter-rouge">isUniqueKey = true</code> 描述了这个字段是一个主键。</p>

<p>第3行 <code class="highlighter-rouge">@FieldMapperAnnotation</code> 与第二行相同，它描述了另一个字段 name，值得注意的是这个字段的类型是 varchar 并且不是主键。</p>

<p>以上 3 个注解描述了表 account 的数据结构，然后我们就可以使用 AccountService 非常方便的操纵数据库的读取了。（AccountService 是 AccountMapper 的实现类，单独使用或在 spring 中使用都有多种方法进行配置，<a href="#AccountService">本文档在附录部分提供了一种配置方法</a>）</p>

<p>使用以下代码，可以查询 id 为 1 的账户：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account account = accountService.select(1);
</code></pre>
</div>
<p>使用以下代码，可以查询 name 为 andy 的 1 条账户数据：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account accountCondition = new Account();
accountCondition.setName("andy");
Account account = accountService.selectOne(accountCondition);
</code></pre>
</div>
<p>与以往的方式相比，这种方式是不是变得优雅了很多？关于 select 和 selectOne 之间的区别，我们在后面的章节会讲到。</p>

<h2 id="flying-特征值描述"><a href="#Index">flying 特征值描述</a></h2>
<p><i>pojo_mapper</i>.xml 中的 flying#{?}:select 即是 flying 的特征值描述，如果您想用 flying 管理一个数据库操作，就用这行值替代原本应该写的 sql 语句，它的格式使用 linux 风格描述如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>flying#{?}:select[:&lt;ignoreTag&gt;]
</code></pre>
</div>
<p>或者</p>
<div class="highlighter-rouge"><pre class="highlight"><code>flying:{selectOne|selectAll|count|insert|update|updatePersistent|delete}[:&lt;ignoreTag&gt;]
</code></pre>
</div>
<p>在第一个“:”之前的部分是 flying 的标识符，为避免复数外键时的缓存问题，当您使用 select 操作时需在 flying 后面加上 #{?}，当您使用其它类型操作时不需要加 #{?}。</p>

<p>第一个“:”和第二个“:”之间的部分是 flying 操作数据的方法，目前支持的方法有：
<code class="highlighter-rouge">select</code>：按主键查询，并返回结果集中的对象；
<code class="highlighter-rouge">selectOne</code>：按条件对象查询，只返回结果集中的第一个对象；
<code class="highlighter-rouge">selectAll</code>：按条件对象查询，返回结果集中所有对象组成的集合；
<code class="highlighter-rouge">count</code>：按条件对象查询，返回结果数量；
<code class="highlighter-rouge">insert</code>：按参数对象增加一条记录；
<code class="highlighter-rouge">update</code>：按参数对象中的非 null 属性更新一条记录，以参数主键为准；
<code class="highlighter-rouge">updatePersistent</code>：按参数对象中的所有属性更新一条记录，以参数主键为准，此操作会把参数对象为 null 属性在数据库中也更新为 null；
<code class="highlighter-rouge">delete</code>：按参数对象的主键删除一条记录；
本文为描述方便，大部分方法名（即方法配置中的 id）与其操作类型（即 flying 特征值的中间部分）相同，实际上方法名可以任意取，当您打算在同一个 <i>pojo_mapper</i>.xml 中定义多个操作类型相同的方法时就会用到。其它操作类型的开发还在评估之中，如果您有想法也可以告诉我们。</p>

<p>第二个“:”之后的部分是忽略标记，忽略标记是可选的。在 select、selectAll、selectOne 类型操作中如果配置了忽略标记，会使返回结果的类定义中配置了相同忽略标记的变量不被查询出来。在其它类型操作中配置忽略标记没有效果。</p>

<p>关于忽略标记更多的内容请见 <a href="#ignore-tag">本文 ignore tag 部分。</a></p>

<h2 id="insert--delete"><a href="#Index">insert &amp; delete</a></h2>
<p>在最基本的 select 之后，我们再看新增功能。但在此之前，需要先在 account.xml 中增加以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;insert id="insert" useGeneratedKeys="true" keyProperty="id"&gt;
    flying:insert
&lt;/insert&gt;
</code></pre>
</div>
<p>上面的 <code class="highlighter-rouge">useGeneratedKeys="true"</code> 表示主键自增，如果您不使用主键自增策略此处可以省略，上面的语句和一般 mybatis 映射文件的区别在于具体 sql 语句变成了 flying 特征值描述。</p>

<p>同样在 AccountMapper.java 中我们需要加入：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public void insert(Account t);
</code></pre>
</div>
<p>然后使用以下代码，可以增加 1 条 name 为 “bob” 的账户数据（由于我们配置了主键自增，新增数据时不需要指定主键）：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account newAccount = new Account();
newAccount.setName("bob");
accountService.insert(newAccount);
</code></pre>
</div>
<p>然后我们再看删除功能。先在 account.xml 中增加以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;delete id="delete"&gt;
    flying:delete
&lt;/delete&gt;
</code></pre>
</div>
<p>然后在 <code class="highlighter-rouge">AccountMapper.java</code> 中加入：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public int delete(Account t);
</code></pre>
</div>
<p>然后使用以下代码，可以删掉 id 与 accountToDelete 的 id 一致的数据。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>accountService.delete(accountToDelete);
</code></pre>
</div>
<p>delete 方法的返回值代表执行 sql 后产生影响的条数，一般来说，返回值为 0 表示 sql 执行后没有效果，返回值为 1 表示 sql 执行成功，在代码中可以通过判断 delete 方法的返回值来实现更复杂的事务逻辑。</p>

<h2 id="update--updatepersistent"><a href="#Index">update &amp; updatePersistent</a></h2>
<p>接下来我们看看更新功能，这里我们要介绍两个方法：update（更新）和 updatePersistent（完全更新）。首先，在 <code class="highlighter-rouge">account.xml</code> 中增加以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;update id="update"&gt;
    flying:update
&lt;/update&gt;
&lt;update id="updatePersistent"&gt;
    flying:updatePersistent
&lt;/update&gt;
</code></pre>
</div>
<p>上面的语句和一般 mybatis 映射文件的区别在于具体 sql 语句变成了 flying 特征值描述。</p>

<p>然后在 <code class="highlighter-rouge">AccountMapper.java</code> 中加入：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public int update(Account t);
public int updatePersistent(Account t);
</code></pre>
</div>
<p>然后使用以下代码，可以将 accountToUpdate 的 name 更新为 “duke” 。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>accountToUpdate.setName("duke");
accountService.update(accountToUpdate);
</code></pre>
</div>
<p>update 和 updatePersistent 方法的返回值代表执行 sql 后产生影响的条数，一般来说，返回值为 0 表示 sql 执行后没有效果，返回值为 1 表示 sql 执行成功，在代码中可以通过判断 update 和 updatePersistent 方法的返回值来实现更复杂的事务逻辑。</p>

<p>下面我们来说明 update 和 updatePersistent 和关系。如果我们执行</p>
<div class="highlighter-rouge"><pre class="highlight"><code>accountToUpdate.setName(null);
accountService.update(accountToUpdate);
</code></pre>
</div>
<p>实际上数据库中这条数据的 name 字段不会改变，因为 flying 对为 null 的属性有保护措施。这在大多数情况下都是合理的，但如果我们真的需要在数据库中将这条数据的 name 字段设为 null，updatePersistent 就派上了用场。我们可以执行：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>accountToUpdate.setName(null);
accountService.updatePersistent(accountToUpdate);
</code></pre>
</div>
<p>这样数据库中这条数据的 name 字段就会变为 null。可见 updatePersistent 会把 pojo 中所有的属性都更新到数据库中，而 update 只更新不为 null 的属性。在实际使用 updatePersistent 时，您需要特别小心慎重，因为当时 pojo 中为 null 的属性有可能比您想象的多。</p>

<h2 id="selectall--count"><a href="#Index">selectAll &amp; count</a></h2>
<p>在之前学习 select 和 selectOne 时，细心的您可能已经发现，这两个方法要完成的工作似乎是相同的。的确 select 和 selectOne 都返回 1 个绑定了数据的 pojo，但它们接受的参数不同：select 接受主键参数；selectOne 接受 pojo 参数，这个 pojo 中的所有被 <code class="highlighter-rouge">@FieldMapperAnnotation</code> 标记过的属性都会作为“相等”条件传递到 sql 语句中。之所以要这么设计，是因为我们有时会需要按照一组条件返回多条数据或者数量，即 selectAll 方法与 count 方法，这个时候以 pojo 作为入参最为合适。为了更清晰的讲述，我们先给 <code class="highlighter-rouge">Account.java</code> 再增加一个属性 address：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "address", jdbcType = JdbcType.VARCHAR)
private java.lang.String address;
/*相关的getter和setter方法请自行补充*/
</code></pre>
</div>
<p>然后我们在 <code class="highlighter-rouge">account.xml</code> 中增加以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;select id="selectAll" resultMap="result"&gt;
    flying:selectAll
&lt;/select&gt;
&lt;select id="count" resultType="int"&gt;
    flying:count
&lt;/select&gt;
</code></pre>
</div>
<p>再在 <code class="highlighter-rouge">AccountMapper.java</code> 中加入</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public Collection&lt;Account&gt; selectAll(Account t);
public int count(Account t);
</code></pre>
</div>
<p>就可以了。例如使用以下代码，可以查询所有 address 为 “beijing” 的数据和数量：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account condition = new Account();
condition.setAddress("beijing");
Collection&lt;Account&gt; accountCollection = accountService.selectAll(condition);
int accountNumber = accountService.count(condition);
</code></pre>
</div>
<p>（当然一般来说执行 selectAll 后就不需要执行 count 了，我们取结果集的 size 即可，但如果我们只关心数量不关心具体数据集时，执行 count 比执行 selectAll 更节省时间）</p>

<p>如果我们想查询所有 address 为 “shanghai” 同时 name 为 “ella” 的账户，则执行以下代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account condition = new Account();
condition.setAddress("shanghai");
condition.setName("ella");
Collection&lt;Account&gt; accountCollection = accountService.selectAll(condition);
</code></pre>
</div>
<p>如果我们知道 address 为 “shanghai” 同时  name 为 “ella” 的账户只有一个，并想直接返回这个数据绑定的 pojo，可以执行： </p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account account = accountService.selectOne(condition);
</code></pre>
</div>
<p>由此可见 selectOne 可以称作是 selectAll 的特殊形式，它只会返回一个 pojo 而不是 pojo 的集合。如果真的有多条数据符合给定的 codition ，也只会返回查询结果中排在最前面的数据。尽管如此，在合适的地方使用 selectOne 代替 selectAll，会让您的程序获得极大方便。</p>

<h2 id="foreign-key"><a href="#Index">foreign key</a></h2>
<p>一般来说我们的 pojo 都是业务相关的，而这些相关性归纳起来无外乎一对一、一对多和多对多。其中一对一是一对多的特殊形式，多对多本质上是由两个一对多组成，所以我们只需要着重解决一对多关系，而 flying 就是为此而生的。</p>

<p>首先我们定义一个新的 pojo：角色（role）。角色和账户是一对多关系，即一个账户只能拥有一个角色，一个角色可以被多个账户拥有。为此我们要新建 <a href="#RoleTableCreater">一个有代表性的 role 表</a>、<code class="highlighter-rouge">role.xml</code>、<code class="highlighter-rouge">RoleMapper.java</code> 以及 <code class="highlighter-rouge">Role.java</code>。<code class="highlighter-rouge">role.xml</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="nt">&lt;mapper</span> <span class="na">namespace=</span><span class="s">"myPackage.RoleMapper"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;cache</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"select"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying#{?}:select
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectOne"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying:selectOne
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectAll"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying:selectAll
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"count"</span> <span class="na">resultType=</span><span class="s">"int"</span><span class="nt">&gt;</span>
        flying:count
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;insert</span> <span class="na">id=</span><span class="s">"insert"</span> <span class="na">useGeneratedKeys=</span><span class="s">"true"</span> <span class="na">keyProperty=</span><span class="s">"id"</span><span class="nt">&gt;</span>
        flying:insert
    <span class="nt">&lt;/insert&gt;</span>
    <span class="nt">&lt;update</span> <span class="na">id=</span><span class="s">"update"</span><span class="nt">&gt;</span>
        flying:update
    <span class="nt">&lt;/update&gt;</span>
    <span class="nt">&lt;update</span> <span class="na">id=</span><span class="s">"updatePersistent"</span><span class="nt">&gt;</span>
        flying:updatePersistent
    <span class="nt">&lt;/update&gt;</span>
    <span class="nt">&lt;delete</span> <span class="na">id=</span><span class="s">"delete"</span><span class="nt">&gt;</span>
        flying:delete
    <span class="nt">&lt;/delete&gt;</span>
    <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">"result"</span> <span class="na">type=</span><span class="s">"Role"</span> <span class="na">autoMapping=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;id</span> <span class="na">property=</span><span class="s">"id"</span> <span class="na">column=</span><span class="s">"role_id"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/resultMap&gt;</span>
<span class="nt">&lt;/mapper&gt;</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">RoleMapper.java</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
public interface RoleMapper {
    public Role select(Object id);
    public Role selectOne(Role t);
    public Collection&lt;Role&gt; selectAll(Role t);
    public void insert(Role t);
    public int update(Role t);
    public int updatePersistent(Role t);
    public int delete(Role t);
    public int count(Role t);
}
</code></pre>
</div>
<p><code class="highlighter-rouge">Role.java</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import org.apache.ibatis.type.JdbcType;
import indi.mybatis.flying.annotations.FieldMapperAnnotation;
import indi.mybatis.flying.annotations.TableMapperAnnotation;
    
@TableMapperAnnotation(tableName = "role")
public class Role {

    @FieldMapperAnnotation(dbFieldName = "role_id", jdbcType = JdbcType.INTEGER, isUniqueKey = true)
    private Integer id;
	    
    @FieldMapperAnnotation(dbFieldName = "role_name", jdbcType = JdbcType.VARCHAR)
    private String roleName;
    /*相关的getter和setter方法请自行补充*/
}
</code></pre>
</div>
<p>然后在 <code class="highlighter-rouge">Account.java</code> 中，加入以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "fk_role_id", jdbcType = JdbcType.INTEGER, dbAssociationUniqueKey = "role_id")
private Role role;   
/*相关的getter和setter方法请自行补充*/
</code></pre>
</div>
<p>以上代码中，<code class="highlighter-rouge">dbFieldName</code> 的值为数据库表 account 中指向表 role 的外键名，<code class="highlighter-rouge">jdbcType</code> 的值为这个外键的类型，<code class="highlighter-rouge">dbAssociationUniqueKey</code> 的值为此外键对应的另一表的主键的名称，写出以上信息后，flying 在代码层面已经完全理解了数据结构。</p>

<p>最后在 <code class="highlighter-rouge">account.xml</code> 的 <code class="highlighter-rouge">resultMap</code> 元素中，加入以下内容</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;association property="role" javaType="Role" select="myPackage.RoleMapper.select" column="fk_role_id" /&gt; 
</code></pre>
</div>
<p>写出以上信息后，flying 在配置文件层面已经完全理解了数据结构。（此处除 association 之外还有另一种使用 typeHandler 的解决方案，稍后您可以在 <a href="#%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90">跨数据源</a> 一节中看到。）</p>

<p>最后总结一下，完整版的 <code class="highlighter-rouge">account.xml</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="nt">&lt;mapper</span> <span class="na">namespace=</span><span class="s">"myPackage.AccountMapper"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;cache</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"select"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying#{?}:select
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectOne"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying:selectOne
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectAll"</span> <span class="na">resultMap=</span><span class="s">"result"</span><span class="nt">&gt;</span>
        flying:selectAll
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"count"</span> <span class="na">resultType=</span><span class="s">"int"</span><span class="nt">&gt;</span>
        flying:count
    <span class="nt">&lt;/select&gt;</span>
    <span class="nt">&lt;insert</span> <span class="na">id=</span><span class="s">"insert"</span> <span class="na">useGeneratedKeys=</span><span class="s">"true"</span> <span class="na">keyProperty=</span><span class="s">"id"</span><span class="nt">&gt;</span>
        flying:insert
    <span class="nt">&lt;/insert&gt;</span>
    <span class="nt">&lt;update</span> <span class="na">id=</span><span class="s">"update"</span><span class="nt">&gt;</span>
        flying:update
    <span class="nt">&lt;/update&gt;</span>
    <span class="nt">&lt;update</span> <span class="na">id=</span><span class="s">"updatePersistent"</span><span class="nt">&gt;</span>
        flying:updatePersistent
    <span class="nt">&lt;/update&gt;</span>
    <span class="nt">&lt;delete</span> <span class="na">id=</span><span class="s">"delete"</span><span class="nt">&gt;</span>
        flying:delete
    <span class="nt">&lt;/delete&gt;</span>
    <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">"result"</span> <span class="na">type=</span><span class="s">"Account"</span> <span class="na">autoMapping=</span><span class="s">"true"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;id</span> <span class="na">property=</span><span class="s">"id"</span> <span class="na">column=</span><span class="s">"account_id"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;association</span> <span class="na">property=</span><span class="s">"role"</span> <span class="na">javaType=</span><span class="s">"Role"</span> <span class="na">select=</span><span class="s">"myPackage.RoleMapper.select"</span> <span class="na">column=</span><span class="s">"fk_role_id"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/resultMap&gt;</span>
<span class="nt">&lt;/mapper&gt;</span>
</code></pre>
</div>
<p>在写完以上代码后，我们看看 flying 能做到什么。首先多对一关系中的<b>一</b>（也即父对象），是可以在多对一关系中的<b>多</b>（也即子对象）查询时自动查询的。为了说明接下来的例子，我们先以 dataset 的方式定义一个数据集</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;dataset&gt;
    &lt;account account_id="1" fk_role_id="10" address="beijing" name="frank" /&gt;
    &lt;account account_id="2" fk_role_id="11" address="tianjin" name="gale" /&gt;
    &lt;account account_id="3" fk_role_id="11" address="beijing" name="hank" /&gt;
    &lt;role role_id="10" role_name="user" /&gt;
    &lt;role role_id="11" role_name="super_user" /&gt;
&lt;/dataset&gt;
</code></pre>
</div>
<p>我们使用这个数据集进行测试，当我们输入以下代码时：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account account1 = accountService.select(1);
/*此时account1的role属性也已经加载了真实数据*/
Role role1 = account1.getRole();
/*role1.getId()为10，role1.getRoleName()为"user"*/
</code></pre>
</div>
<p>这种传递是可以迭代的，即如果 Role 自己也有父对象，则 Role 的父对象也会一并加载，只要它的配置文件和代码正确。</p>

<p>不仅如此，我们可以在入参 pojo 中加入父对象，比如下面的代码查询的是角色名为 “super_user” 的所有帐户：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Role roleCondition = new Role();
roleCondition.setRoleName("super_user");
Account accountCondition = new Account();
accountCondition.setRole(roleCondition);
Collection&lt;Account&gt; accounts = accountService.selectAll(accountCondition);
/*accounts.seiz()为 2，里面包含的对象的 account_id 是 2 和 3*/

/*我们再给入参pojo加一个address限制*/
accountCondition.setAddress("beijing");
Collection&lt;Account&gt; accounts2 = accountService.selectAll(accountCondition);
/*accounts.size()为 1，里面包含的对象的 account_id 是 3，这说明 account 的条件和父对象 role 的条件同时生效*/
</code></pre>
</div>
<p>这个特性在 selectOne、count 中同样存在</p>

<p>最后，父对象同样可以参与子对象的 insert、update、updatePersistent，代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Account newAccount = new Account();

/*我们新建一个姓名为 iris，角色名称为 "user" 的账号*/
newAccount.setName("iris");

/*角色名称为 "user" 的数据的 role_id 是 10，由变量 role1 来加载它*/
Role role1 = roleService.select(10);
newAccount.setRole(role1);
accountService.insert(newAccount);
/*一个姓名为iris，角色名称为"user"的账号建立完成*/

/*我们用update方法将iris的角色变为"super_user"*/
/*角色名称为"super_user"的数据的role_id是11，由变量role2来加载了它*/
Role role2 = roleService.select(11);
newAccount.setRole(role2);
accountService.update(newAccount);
/*现在newAccount.getRole().getId()为11，newAccount.getRole().getRoleName为"super_user"*/

/*我们用updatePersistent方法将iris的角色变为null，即与Role对象不再关联*/
newAccount.setRole(null);
accountService.updatePersistent(newAccount);
/*现在 newAccount.getRole()为 null，在数据库中也不再有关联（注意在这里 update 方法起不到这种效果，因为 update 会忽略 null）*/
</code></pre>
</div>

<h2 id="complex-condition"><a href="#Index">complex condition</a></h2>
<p>之前我们展示的例子中，条件只有“相等”一种，但在实际情况中我们会遇到各种各样的条件：大于、不等于、like、in、is not null 等等。这些情况 flying 也是能够处理的，但首先我们要引入一个“条件对象”的概念。条件对象是实体对象的子类，但它只为查询而存在，它拥有实体对象的全部属性，同时它还有一些专为查询服务的属性。例如下面是 Account 对象的条件对象 AccountCondition 的代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import java.util.Collection;
import java.util.List;
import indi.mybatis.flying.annotations.ConditionMapperAnnotation;
import indi.mybatis.flying.annotations.QueryMapperAnnotation;
import indi.mybatis.flying.models.Conditionable;
import indi.mybatis.flying.statics.ConditionType;
@QueryMapperAnnotation(tableName = "account")
public class AccountCondition extends Account implements Conditionable {

    @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.Like)
    /*用作 name 全匹配的值*/
    private String nameLike;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.HeadLike)
    /*用作 address 开头匹配的值*/
    private String addressHeadLike;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.TailLike)
    /*用作 address 结尾匹配的值*/
    private String addressTailLike;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.MultiLikeAND)
    /*用作 address 需要同时匹配的若干个值的集合（类型只能为List）*/
    private List&lt;String&gt; addressMultiLikeAND;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.MultiLikeOR)
    /*用作 address*/ 需要至少匹配之一的若干个值的集合（类型只能为List）
    private List&lt;String&gt; addressMultiLikeOR;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.In)
    /*用作 address*/ 可能等于的若干个值的集合（类型可为任意Collection）
    private Collection&lt;String&gt; addressIn;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.NotIn)
    /*用作 address 不可能等于的若干个值的集合（类型可为任意Collection）*/
    private Collection&lt;String&gt; addressNotIn;
	
    @ConditionMapperAnnotation(dbFieldName = "address", conditionType = ConditionType.NullOrNot)
    /*用作 address 是否为 null 的判断（类型只能为Boolean）*/
    private Boolean addressIsNull;
	
    /*相关的getter和setter方法请自行补充*/
	
    /*以下四个方法是实现 Conditionable 接口后必须要定义的方法，我们这里只写出默认实现，在下一节中我们会详细介绍它们*/
    @Override
    public Limitable getLimiter() {
        return null;
    }
    @Override
    public void setLimiter(Limitable limiter) {
    }
    @Override
    public Sortable getSorter() {
        return null;
    }
    @Override
    public void setSorter(Sortable sorter) {
    }
}
</code></pre>
</div>
<p>以上各种条件并非要全部写出，您可以只写出业务需要的条件（变量名可以是任意的，只要条件标注准确即可）。在 flying 中进行复杂条件查询前需要先按需求写一些条件代码，但请您相信，从长远来看这种做法的回报率是极高的。然后我们可以进行测试：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/*查询名称中带有"a"的帐户数量*/
AccountCondition condition1 = new AccountCondition();
condition1.setNameLike("a");
int count1 = accountService.count(condition1);

/*查询地址以"bei"开头的帐户的数量*/
AccountCondition condition2 = new AccountCondition();
condition2.setAddressHeadLike("bei");
int count2 = accountService.count(condition2);

/*查询地址以"jing"结尾的帐户的数量*/
AccountCondition condition3 = new AccountCondition();
condition3.setAddressTailLike("jing");
int count3 = accountService.count(condition3);

/*查询地址同时包含"e"和"i"的账户的数量*/
List&lt;String&gt; listAddressMultiLikeAND = new ArrayList&lt;&gt;();
listAddressMultiLikeAND.add("e");
listAddressMultiLikeAND.add("i");
AccountCondition condition4 = new AccountCondition();
condition4.setAddressMultiLikeAND(listAddressMultiLikeAND);
int count4 = accountService.count(condition4);

/*查询地址至少包含"e"或"i"的账户的数量*/
List&lt;String&gt; listAddressMultiLikeOR = new ArrayList&lt;&gt;();
listAddressMultiLikeOR.add("e");
listAddressMultiLikeOR.add("i");
AccountCondition condition5 = new AccountCondition();
condition5.setAddressMultiLikeOR(listAddressMultiLikeOR);
int count5 = accountService.count(condition5);

/*查询地址等于"beijing"或"shanghai"中的一个的账户的数量*/
List&lt;String&gt; listAddressIn = new ArrayList&lt;&gt;();
listAddressIn.add("beijing");
listAddressIn.add("shanghai");
AccountCondition condition6 = new AccountCondition();
condition6.setAddressIn(listAddressIn);
int count6 = accountService.count(condition6);

/*查询地址不等于"beijing"或"shanghai"的账户的数量*/
List&lt;String&gt; listAddressNotIn = new ArrayList&lt;&gt;();
listAddressNotIn.add("beijing");
listAddressNotIn.add("shanghai");
AccountCondition condition7 = new AccountCondition();
condition7.setAddressNotIn(listAddressNotIn);
int count7 = accountService.count(condition7);

/*查询地址为null的账户的数量*/
AccountCondition condition8 = new AccountCondition();
condition8.setAddressIsNull(true);
int count8 = accountService.count(condition8);

/*最后我们查询名称中带有"a"且地址为"beijing"的帐户的数量*/
AccountCondition conditionX = new AccountCondition();
conditionX.setNameLike("a");
conditionX.setAddress("beijing");
int countX = accountService.count(conditionX);
/*这个用例说明条件变量也可以使用 pojo 本身的字段进行查询*/
</code></pre>
</div>
<h2 id="limiter--sorter"><a href="#Index">limiter &amp; sorter</a></h2>
<p>在之前的 selectAll 查询中我们都是取符合条件的所有值，但在实际业务需求中很少会这样做，更多的情况是我们会有一个数量限制。同时我们还会希望结果集是经过某种条件排序，甚至是经过多种条件排序的，幸运的是 flying 已经为此做好了准备。</p>

<p>一个可限制数量并可排序的查询也是由条件对象来实现的，代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import indi.mybatis.flying.annotations.QueryMapperAnnotation;
import indi.mybatis.flying.models.Conditionable;
import indi.mybatis.flying.models.Limitable;
import indi.mybatis.flying.models.Sortable;
@QueryMapperAnnotation(tableName = "account")
public class AccountCondition extends Account implements Conditionable {
    private Limitable limiter;
    private Sortable sorter;
    @Override
    public Limitable getLimiter() {
        return limiter;
    }
    @Override
    public void setLimiter(Limitable limiter) {
        this.limiter = limiter;
    }
    @Override
    public Sortable getSorter() {
        return sorter;
    }
    @Override
    public void setSorter(Sortable sorter) {
        this.sorter = sorter;
    }
}
</code></pre>
</div>
<p>以上 limiter 和 sorter 变量名并非固定，只要类引入了 Conditionable 接口并实现相关方法，且在相关方法中对应上您定义的 limiter 和 sorter 即可。
然后可以采用如下代码进行测试：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>import indi.mybatis.flying.models.Conditionable;
import indi.mybatis.flying.pagination.Order;
import indi.mybatis.flying.pagination.PageParam;
import indi.mybatis.flying.pagination.SortParam;

/*查询 account 表在默认排序下前 10 条数据*/
AccountCondition condition1 = new AccountCondition();
/*PageParam 的构造函数中第一个参数为起始页数，第二个参数为每页容量，new PageParam(0,10)即从头开始取 10 条数据*/
condition1.setLimiter(new PageParam(0, 10));
Collection&lt;Account&gt; collection1 = accountService.selectAll(codition1);

/*查询 account 表在默认排序下第 8 条数据*/
AccountCondition condition2 = new AccountCondition();
/*new PageParam(7,1)即从第 7 条开始取 1 条数据*/
condition2.setLimiter(new PageParam(7, 1));
/*因为结果只需要一条数据，我们可以使用 selectOne 方法*/
Account account2 = accountService.selectOne(condition2);

/*查询 account 表在 name 正序排序下的所有数据*/
AccountCondition condition3 = new AccountCondition();
/*new Order()的第一个参数是被排序的字段名，第二个参数是正序或倒序*/
condition3.setSorter(new SortParam(new Order("name", Conditionable.Sequence.asc)));
Collection&lt;Account&gt; collection3 = accountService.selectAll(codition3);

/*查询 account 表先在 name 正序排序，然后在 address 倒序排序下的所有数据*/
AccountCondition condition4 = new AccountCondition();
/*在new SortParam()中可以接受不定数量的 Order 参数，因此我们先新建一个 name 正序，再新建一个 address 倒序*/
condition4.setSorter(new SortParam(new Order("name", Conditionable.Sequence.asc),new Order("address", Conditionable.Sequence.desc)));
Collection&lt;Account&gt; collection4 = accountService.selectAll(codition4);

/*最后我们查询在 name 正序排序下的第 11 到 20 条数据*/
AccountCondition conditionX = new AccountCondition();
conditionX.setSorter(new SortParam(new Order("name", Conditionable.Sequence.asc)));
conditionX.setLimiter(new PageParam(1, 10));
Collection&lt;Account&gt; collectionX = accountService.selectAll(coditionX);
/*这个用例说明 limiter 和 sorter 是可以组合使用的*/
</code></pre>
</div>
<p>因为 limiter 和 sorter 也是以条件对象的方式定义，所以可以和复杂查询一起使用，只要在条件对象中既包含条件标注又包含 Limitable 和 Sortable 类型的变量即可。</p>
<h2 id="分页"><a href="#Index">分页</a></h2>
<p>在大多数实际业务需求中，我们的 limiter 和 sorter 都是为分页服务。在 flying 中，我们提供了一种泛型 Page&lt;?&gt; 来封装查询出的数据。使用 Page&lt;?&gt; 的好处是，它除了提供数据内容（pageItems）外还提供了全部数量（totalCount）、最大页数（maxPageNum）、当前页数（pageNo）等信息，这都是数据接收端希望了解的信息。并且这些数量信息是 flying 自动获取的，您只需执行下面这样的代码即可：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>import indi.mybatis.flying.pagination.Page;

AccountCondition condition = new AccountCondition();
condition.setLimiter(new PageParam(0, 10));
Collection&lt;Account&gt; collection = accountService.selectAll(condition);

/*下面这句代码就将查询结果封装为了 Page&lt;?&gt; 对象*/
Page&lt;Account&gt; page = new Page&lt;&gt;(collection, condition.getLimiter());
/*需要注意的是上面的入参 condition.getLimiter() 是不能用其它任意 PageParam 对象代替的，因为在之前执行 selectAll 时已经将一些信息保存到 condition.getLimiter() 中*/
</code></pre>
</div>
<p>假设总的数据有 21 条，则 <code class="highlighter-rouge">page.getTotalCount()</code> 为 21，<code class="highlighter-rouge">pagegetMaxPageNum()</code> 为 3，<code class="highlighter-rouge">page.getPageNo()</code> 为 1，<code class="highlighter-rouge">page.getPageItems()</code> 为第一到第十条数据的集合。</p>
<h2 id="乐观锁"><a href="#Index">乐观锁</a></h2>
<p>乐观锁是实际应用的数据库设计中重要的一环，而 flying 在设计之初就考虑到了这一点，
目前 flying 只支持版本号型乐观锁。在 flying 中使用乐观锁的方法如下：
在数据结构中增加一个表示乐观锁的 Integer 型字段 opLock 即可：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "opLock", jdbcType = JdbcType.INTEGER, opLockType = OpLockType.Version)
private Integer opLock;
/*乐观锁可以增加 getter 方法，不建议增加 setter 方法*/
</code></pre>
</div>
<p>以上实际上是给 <code class="highlighter-rouge">@FieldMapperAnnotation</code> 中的 <code class="highlighter-rouge">opLockType</code> 上赋予了 <code class="highlighter-rouge">OpLockType.Version</code>，这样 flying 就会明白这是一个起乐观锁作用的字段。当含有乐观锁的表 account 更新时，实际 sql 会变为：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>update account ... and opLock = opLock + 1 where id = '${id}' and opLock = '${opLock}'
</code></pre>
</div>
<p>（上面 … 中的内容是给其它的字段赋值）</p>

<p>每次更新时都会加入 opLock 的判断，并且更新数据时 opLock 自增 1 ，这样就可以保证多个线程对同一个 account 执行 update 或 updatePersistent 时只有一个能执行成功，即达到了我们需要的锁效果。</p>

<p>当含有乐观锁的表 account 删除时，实际 sql 会变为：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>delete from account where id = '${id}' and opLock = '${opLock}'
</code></pre>
</div>
<p>即只有 opLock 和 id 都符合时才能被删除，这里乐观锁起到了保护数据的作用。</p>

<p>在实际应用中，可以借助 update、updatePersistent、delete 方法的返回值来判断是否变动了数据（一般来说返回 0 表示没变动，1 表示有变动），继而判断锁是否有效，是否合法（符合业务逻辑），最后决定整个事务是提交还是回滚。</p>

<p>最后我们再来谈谈为什么不建议给乐观锁字段加上 setter 方法。首先在代码中直接修改一个 pojo 的乐观锁值是很危险的事情，它会导致事务逻辑的不可靠；其次乐观锁不参与 select、selectAll、selectOne 方法，即便给它赋值在查询时也不会出现；最后乐观锁不参与 insert 方法，无论给它赋什么值在新增数据中此字段的值都是零，即乐观锁总是从零开始增长。</p>
<h2 id="其它"><a href="#Index">其它</a></h2>
<h3 id="ignore-tag"><a href="#Index">ignore tag</a></h3>
<p>有时候，我们希望在查询中忽略某个字段的值，但在作为查询条件和更新时要用到这个字段。一个典型的场景是 password 字段，出于安全考虑我们不想在 select 方法返回的结果中看到它的值，但我们需要在查询条件（如判断登录）和更新（如修改密码）时使用到它，这时我们可以在 Account.java 中加入以下代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "password", jdbcType = JdbcType.VARCHAR, ignoreTag = { "noPassword" })
private String password;
/*相关的getter和setter方法请自行补充*/
</code></pre>
</div>
<p>这样我们将 <code class="highlighter-rouge">password</code> 这个字段加上了一个忽略标记 <code class="highlighter-rouge">noPassword</code>，然后在查询 account 表时相关 flying 特征值最后加上 <code class="highlighter-rouge">:noPassword</code> 就不会再查找 password 字段，但作为查询条件和更新数据时 password 字段都可以参与进来，如下所示：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;select id="selectOne" resultMap="result"&gt;
    flying:selectOne:noPassword
&lt;/select&gt;
</code></pre>
</div>
<p>然后，可通过代码验证 <code class="highlighter-rouge">password</code> 属性已被忽略</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/*查找 name 为 "user" 且 password 为 "123456" 的一个账户*/
Account condition = new Account();
condition.setName("user");
condition.setPassword("123456");
Account account = accountService.selectOne(condition);
/*用以上方式是可以查出 passeord 为 "123456" 的账户的，然而结果中 account.getPassword()为 null*/

/* 但是仍然可以更新 password 的值 */
account.setPassword("654321");
accountService.update(account);
/*现在 account 对应的数据库中数据的 password 字段值变为 "654321"*/
</code></pre>
</div>
<p>另一种场景是查询对象中有一个长度很大的属性，例如我们在数据库中有一个类型为 varchar 长度为 3000 的属性 <code class="highlighter-rouge">detail</code>，为性能考虑，在不需要查看 <code class="highlighter-rouge">detail</code> 详情的情况下我们不想将其 select 出来，而忽略标记就可以做到这一点。我们在 account.java 中增加如下代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "detail", jdbcType = JdbcType.VARCHAR, ignoreTag = { "noDetail" })
private String detail;
/*相关的getter和setter方法请自行补充*/
</code></pre>
</div>
<p>此时用 flying 特征值为 <code class="highlighter-rouge">flying#{?}:select:noDetail</code> 的方法就不会查出 <code class="highlighter-rouge">detail</code> 字段；如果我们在某些情况又需要得到 <code class="highlighter-rouge">detail</code> 的内容，再增加一个特征值不带 <code class="highlighter-rouge">:noDetail</code> 的查询方法即可，例如直接用 <code class="highlighter-rouge">flying#{?}:select</code>。</p>

<p>如果我们想既不查询 <code class="highlighter-rouge">detail</code> 又不查询 <code class="highlighter-rouge">password</code>，可在 <code class="highlighter-rouge">password</code> 的注解上使用多个忽略标记，就像下面这样：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "password", jdbcType = JdbcType.VARCHAR, ignoreTag = { "noPassword", "noDetail" })
private String password;
</code></pre>
</div>
<p>这时特征值 <code class="highlighter-rouge">flying#{?}:select:noDetail</code> 就既忽略 <code class="highlighter-rouge">detail</code> 又忽略 <code class="highlighter-rouge">password</code>。
由此可见，在实体类中一个属性可配置多个忽略标记，其中一个被激活这个属性就不会参与查询；但是 flying 特征值每次只能激活一个忽略标记，所以如果您有多样化的忽略需求，您需要在实体类中仔细配置以满足需要。</p>

<p>最后，flying 特征值中的忽略标记没有传递性，只对当前查询对象有效而对自动查询的父对象无效。例如对 <code class="highlighter-rouge">Account</code> 对象的 <code class="highlighter-rouge">flying#{?}:select:noPassword</code> 查询，其忽略标记对自动查询的父对象 <code class="highlighter-rouge">Role</code> 无效，哪怕 <code class="highlighter-rouge">Role</code> 中有 <code class="highlighter-rouge">ignoreTag</code> 等于 ‘noPassword’ 的属性也会查询出来。如果您需要激活自动查询的父对象中的忽略标记，您需要调整 <code class="highlighter-rouge">&lt;resultMap&gt;</code> 中的 <code class="highlighter-rouge">&lt;association&gt;</code> 的设置，让其指向一个激活了忽略标记的查询，例如：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;association property="role" javaType="Role" select="myPackage.RoleMapper.selectIgnore_" column="fk_role_id" /&gt;
</code></pre>
</div>
<p>如果您既需要带有激活忽略标记的自动查询父对象又需要不带激活忽略标记的自动查询父对象，那您为查询对象定义多个 <code class="highlighter-rouge">resultMap</code> 即可。</p>
<h3 id="复数外键"><a href="#Index">复数外键</a></h3>
<p>有时候一个数据实体会有多个多对一关系指向另一个数据实体，例如考虑下面的情况：我们假设每个账户都有一个兼职角色，这样 account 表中就需要另一个字段 fk_second_role_id，而这个字段也是指向 role 表。为了满足这个需要，首先我们要在 account.xml 的 resultMap元素中，加入以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;association property="secondRole" javaType="Role" select="myPackage.RoleMapper.select" column="fk_second_role_id" /&gt;
</code></pre>
</div>
<p>然后在 Account.java 中还需要加入以下代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@FieldMapperAnnotation(dbFieldName = "fk_second_role_id", jdbcType = JdbcType.INTEGER, dbAssociationUniqueKey = "role_id")
private Role secondRole;   
/*相关的getter和setter方法请自行补充*/
</code></pre>
</div>
<p>如此一来表 account 和表 role 就构成了复数外键关系。flying 支持复数外键，您可以像操作普通外键一样操作它，代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/*查询角色名称为 "user",同时兼职角色名称为 "super_user" 的账户*/
Account condition = new Account();
Role role = new Role(), secondRole = new Role();
role.setName("user");
condition.setRole(role);
secondRole.setName("super_user");
condition.setSecondRole(secondRole);
Collection&lt;Account&gt; accounts = accountService.selectAll(condition);
</code></pre>
</div>
<p>可见，复数外键的增删改查等操作与普通外键是类似的，只需要注意虽然 secondRole 的类型为Role，但它的 getter、setter 是 getSecondRole()、setSecondRole()，而不是 getRole()、setRole()即可。</p>
<h3 id="跨数据源"><a href="#Index">跨数据源</a></h3>
<p><code class="highlighter-rouge">最新版本新增</code> 在实际开发中，越来越多的系统采用分布式数据库设计，flying 对此也提供支持。flying 采用的是真实数据源配合自定义 TypeHandler 的方式，而非动态切换虚拟数据源方式，这样做的好处如下：</p>
<ul>
  <li>动态切换虚拟数据源方式需要频繁切换数据源，而真实数据源方式本身就是多个数据源无需切换，避免了这方面的开销。</li>
  <li>动态切换虚拟数据源方式多数据源和单数据源实现差异较大，用户如果从单数据源升级至多数据源需要变更很多内容；而采用真实数据源配合自定义 TypeHandler 的方式，完全利用了 mybatis 自身支持多数据源特性，将单数据源看做多数据源的一种特例，每次新增数据源的配置都很少且易于理解。</li>
  <li>flying 对真实数据源配合自定义 TypeHandler 的方式进行了优化，当您在业务代码中调用数据时您不需要知道哪些是跨数据源调用哪些是单数据源调用，您也基本感知不到它们的不同。</li>
</ul>

<p>为了更好的说明 flying 跨数据源实现方式，在本小节中，我们假定 Account 表和 Role 表处于不同的数据源内，前者的数据源为 dataSource1，后者的数据源为 dataSource2。因此 spring 中的配置如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>    &lt;bean id="dataSource1" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" /&gt;
    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
	&lt;property name="configLocation" value="classpath:Configuration.xml" /&gt;
	&lt;property name="dataSource" ref="dataSource1" /&gt;
	&lt;property name="mapperLocations" value="classpath*:myPackage/mapper/*.xml" /&gt;
	&lt;property name="typeAliasesPackage" value="myPackage" /&gt;
    &lt;/bean&gt;
    &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
	&lt;property name="basePackage" value="myPackage" /&gt;
	&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;bean id="dataSource2" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" /&gt;
    &lt;bean id="sqlSessionFactory2" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
	&lt;property name="configLocation" value="classpath:Configuration.xml" /&gt;
	&lt;property name="dataSource" ref="dataSource2" /&gt;
	&lt;property name="mapperLocations" value="classpath*:myPackage/mapper2/*.xml" /&gt;
	&lt;property name="typeAliasesPackage" value="myPackage" /&gt;
    &lt;/bean&gt;
    &lt;bean id="mapperScannerConfigurer2" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
	&lt;property name="basePackage" value="myPackage" /&gt;
	&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory2" /&gt;
    &lt;/bean&gt;

    &lt;!--因为TypeHandler并非第一时间初始化，不能以@Autowired方式调用Bean，所以增加ApplicationContextProvider方式来调用Bean--&gt;
    &lt;bean id="applicationContextProvder" class="indi.demo.flying.ApplicationContextProvider" /&gt;
</code></pre>
</div>
<p>以上配置文件中描述了两个数据源 <code class="highlighter-rouge">dataSource1</code> 和 <code class="highlighter-rouge">dataSource2</code> 以及它们对应的 <code class="highlighter-rouge">sqlSessionFactory</code> 和 <code class="highlighter-rouge">mapperScannerConfigurer</code>，至于最后的 <code class="highlighter-rouge">applicationContextProvder</code>，它的具体代码是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package indi.demo.flying;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class ApplicationContextProvider implements ApplicationContextAware {
	private static ApplicationContext context;

	public static ApplicationContext getApplicationContext() {
		return context;
	}

	@Override
	public void setApplicationContext(ApplicationContext ctx) throws BeansException {
		context = ctx;
	}
}
</code></pre>
</div>
<p>这个 <code class="highlighter-rouge">ApplicationContextProvider</code> 的作用我们后面就会看到。之后我们还要替换 Account 类中 role 属性的注解，如下所示：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>    @FieldMapperAnnotation(dbFieldName = "fk_role_id", jdbcType = JdbcType.INTEGER, dbAssociationTypeHandler = myPackage.typeHandler.RoleTypeHandler.class)
    private Role role;
</code></pre>
</div>
<p>这实际上是将原本的 <code class="highlighter-rouge">dbAssociationUniqueKey</code> 替换为 <code class="highlighter-rouge">dbAssociationTypeHandler</code>，而 <code class="highlighter-rouge">dbAssociationTypeHandler</code> 需要指定一个类作为值，所以我们还要开发一个 RoleTypeHandler，如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage.typeHandler;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.MappedTypes;
import org.apache.ibatis.type.TypeHandler;
import indi.demo.flying.ApplicationContextProvider;
import myPackage.Role;
import myPackage.RoleService;

@MappedTypes({ Role.class })
public class RoleTypeHandler extends BaseTypeHandler&lt;Role&gt; implements TypeHandler&lt;Role&gt; {
	@Override
	public Role getNullableResult(ResultSet arg0, String arg1) throws SQLException {
		if (arg0.getString(arg1) == null) {
			return null;
		}
		return (getService().mySelect(arg0.getString(arg1)));
	}
	@Override
	public Role getNullableResult(ResultSet arg0, int arg1) throws SQLException {
		if (arg0.getString(arg1) == null) {
			return null;
		}
		return (getService().mySelect(arg0.getString(arg1)));
	}
	@Override
	public Role getNullableResult(CallableStatement arg0, int arg1) throws SQLException {
		if (arg0.getString(arg1) == null) {
			return null;
		}
		return (getService().mySelect(arg0.getString(arg1)));
	}
	@Override
	public void setNonNullParameter(PreparedStatement arg0, int arg1, Role arg2, JdbcType arg3) throws SQLException {
		if (arg2 != null) {
			arg0.setString(arg1, arg2.getId());
		}
	}

	/*
	 * 因为此TypeHandler并非第一时间初始化，不能以@Autowired方式调用RoleService，所以采用下面的方式
	 */
	private RoleService getService() {
		return (RoleService) ApplicationContextProvider.getApplicationContext().getBean(RoleService.class);
	}
}
</code></pre>
</div>
<p>如果您对这个类的代码不是很熟悉，您可以了解一下 mybatis 自定义 TypeHandler 的机制。另外，您可以看到我们之前开发的 <code class="highlighter-rouge">ApplicationContextProvider</code> 在此处发挥了作用。最后，我们还要修改 account.xml 中的 resultMap，如下所示：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>    &lt;resultMap id="result" type="Account" autoMapping="true"&gt;
        &lt;id property="id" column="account_id" /&gt;
        &lt;result property="role" typeHandler="myPackage.typeHandler.RoleTypeHandler" column="fk_role_id" /&gt;
    &lt;/resultMap&gt;
</code></pre>
</div>
<p>以上是把 resultMap 中的 association 方式替换为 typeHandler 方式，关于 association 方式和 typeHandler 方式的区别，<a href="#association-or-typeHandler">您可以参考这里</a>。</p>

<p>现在，您就可以使用如下代码来操作跨数据源的 Account 和 Role 对象了：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/* 跨数据源时，也可以新建关联了父对象的子对象 */
Account newAccount = new Account();
newAccount.setRole(role);
accountService.insert(newAccount);
/* 此时数据库中新增的newAccount已于另一数据源的role关联起来 */

/* 跨数据源时，子对象查询时也可自动加载父对象 */
Account account = accountService.select(newAccount.getId());
/* 此时account.getRole()的值即account关联的处于另一数据源的role */

/* 跨数据源时，子对象也可更新父对象 */
account.setRole(otherRole);
accountService.update(account);
/* 此时数据库中account和另一数据源的otherRole关联起来 */
</code></pre>
</div>
<p>然而跨数据源关联毕竟不同于单数据源，它无法做到将父对象除主键外的其它属性作为条件参与查询。实际上这是由于数据库的限制，目前大部分的数据库还不支持跨数据源的外键关联查询，更不用说是跨数据源异构数据库（例如一方是 oracle 另一方是 mysql）。当然对于支持跨数据源外键关联查询的数据库（例如使用了 mysql 的 federated 引擎），我们在今后也会考虑支持它的特性。</p>

<p><a id="flying-demo2"></a>
最后，这里有一个<a href="https://github.com/limeng32/flying-demo2">跨数据源应用的代码示例</a>，相信您看完以后会对 flying 实现跨数据源的方法了然于胸。（同时这个例示还使用了 mybatis 的二级缓存，关于此方面内容我们会在下一篇文章中进行详细介绍）</p>
<h2 id="附录"><a href="#Index">附录</a></h2>
<p><a id="FAQ"></a></p>
<h3 id="常见问题"><a href="#Index">常见问题</a></h3>
<p><a id="why-no-sql"></a>
1、为何<i>pojo_mapper</i>.xml 中没有 sql 语句细节？</p>

<p>A：flying 的 sql 语句是动态生成的，只要您指定了正确的字段名，就绝对不会出现 sql 书写上的问题。并且 flying 采用了缓存机制，您无需担心动态生成 sql 的效率问题。</p>

<p><a id="association-or-typeHandler"></a>
2、<code class="highlighter-rouge">最新版本新增</code> resultMap 中 association 和 typeHandler 两种方式的区别？</p>

<p>A：在单数据源情况下，这两种方式都可以实现“查询子对象时自动加载父对象”的需要；但在多数据源的情况下，只有 typeHandler 方式才能实现跨数据源关联。我们的建议是在任何情况下都只使用 typeHandler 方式，因为如果您打算在多数据源环境下并且使用 mybatis 的二级缓存，只有全部 resultMap 都采用 typeHandler 才能保证缓存的完整一致性。（在下一篇文章中会对此详细讲解）
<a id="AccountTableCreater"></a></p>
<h3 id="代码示例"><a href="#Index">代码示例</a></h3>
<p><code class="highlighter-rouge">最新版本新增</code> 为了您更方便的使用 flying 进行开发，我们提供了一个<a href="https://github.com/limeng32/flying-demo">覆盖了本文大部分功能的单数据源的代码示例</a>。如果您是对跨数据源感兴趣，则您应该关注<a href="#flying-demo2">这里</a>。</p>
<h3 id="account-表建表语句"><a href="#Index">account 表建表语句</a></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>CREATE TABLE account (
  account_id int(11) NOT NULL AUTO_INCREMENT,
  name varchar(20) DEFAULT NULL,
  address varchar(100) DEFAULT NULL,
  fk_role_id int(11) DEFAULT NULL,
  fk_second_role_id int(11) DEFAULT NULL,
  PRIMARY KEY (account_id)
)
</code></pre>
</div>

<p><a id="RoleTableCreater"></a></p>
<h3 id="role-表建表语句"><a href="#Index">role 表建表语句</a></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>CREATE TABLE role (
  role_id int(11) NOT NULL AUTO_INCREMENT,
  role_name varchar(30) DEFAULT NULL,
  PRIMARY KEY (role_id)
)
</code></pre>
</div>

<p><a id="AccountService"></a></p>
<h3 id="accountservice-的实现方式"><a href="#Index">AccountService 的实现方式</a></h3>
<p>在 spring 3.x 及更高版本中，可以按以下方式构建一个 <i>pojoService</i>.java 类：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;

import java.util.Collection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AccountService implements AccountMapper {

	@Autowired
	private AccountMapper mapper;

	@Override
	public Account select(Object id) {
		return mapper.select(id);
	}

	@Override
	public Account selectOne(Account t) {
		return mapper.selectOne(t);
	}
	
	@Override
	public Collection&lt;Account&gt; selectAll(Account t) {
		return mapper.selectAll(t);
	}
	
	@Override
	public void insert(Account t) {
		mapper.insert(t);
	}

	@Override
	public int update(Account t) {
		return mapper.update(t);
	}

	@Override
	public int updatePersistent(Account t) {
		return mapper.updatePersistent(t);
	}

	@Override
	public int delete(Account t) {
		return mapper.delete(t);
	}

	@Override
	public int count(Account t) {
		return mapper.count(t);
	}
}
</code></pre>
</div>
    </content>
  </entry>
  <entry>
    <title>使用flying完善Mybatis自带的二级缓存</title>
    <link href="http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E5%AE%8C%E5%96%84Mybatis%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"/>
    <updated>2017-10-16T00:00:00+00:00</updated>
    <id>http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E5%AE%8C%E5%96%84Mybatis%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id>
    <content type="html">
      <h2 id="上手指南"><a href="#Index">上手指南</a></h2>
<p>上一篇文章中我们介绍了使用 flying 解决 pojo 自动映射问题，在本篇文章中我们介绍如何使用 flying 优化后的 mybatis 自带二级缓存。mybatis 自带的二级缓存方便上手容易使用，并且如果您把它和 redis 等第三方缓存结合使用，它就能成为可扩展的强大缓存；如果您的系统用户数不到一千并且您不想为缓存配置额外的服务器，那您也可以只使用 mybatis 的二级缓存，因为它的使用成本极低。</p>

<p>mybatis 的二级缓存只存在于内存中，不会写入硬盘，但可以通过 redis 来实现数据落地，在使用前请确保您的业务可以接受这些特性。</p>

<p>为使用 flying 优化后的 mybatis 自带二级缓存，您只需要在 Configuration.xml 和 <i>pojo_mapper</i>.java 中进行简单的配置。在 Configuration.xml 中配置的内容是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;settings&gt;
	&lt;setting name="cacheEnabled" value="true" /&gt;
	&lt;setting name="lazyLoadingEnabled" value="false" /&gt;
	&lt;setting name="aggressiveLazyLoading" value="false" /&gt;
	&lt;setting name="localCacheScope" value="SESSION" /&gt;
	&lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;
	&lt;setting name="lazyLoadTriggerMethods" value="" /&gt;
&lt;/settings&gt;
</code></pre>
</div>
<p>需要注意的是 <code class="highlighter-rouge">settings</code> 中第一行 <code class="highlighter-rouge">cacheEnabled</code> 的值为 <code class="highlighter-rouge">true</code>，其它内容都和 <a href="http://flying-doc.limeng32.com/flying-%E6%98%AF%E4%BB%80%E4%B9%88">《flying-是什么》</a> 中介绍的配置完全一致。</p>

<p>在完成上述工作后，mybatis 的二级缓存就可以使用了。现在启动项目后，每次对数据库发起的查询请求都会被缓存进行拦截，如果在缓存中能找到结果（包括单个 pojo、pojo集合、数量等）就直接返回结果，不会对数据库产生压力；如果找不到结果再去数据库中进行查询，查询后返回结果的同时把此次结果记入缓存中，这样下次再进行相同条件查询时如果相关记录没进行过刷新型操作（如 update、delete），就会返回缓存中的结果；如果对某条数据进行了 update、delete 操作，会使得相关缓存失效，其中的机制在后面会有详细介绍。</p>

<p>由于服务容器刚启动时缓存中没有任何内容，因此所有查询第一次都会经过数据库，在此之后缓存将发挥作用。为了更好的说明，我们需要新建<a href="#AccountTableCreater">一个账号表</a>和<a href="#RoleTableCreater">一个角色表</a>、相关的 <code class="highlighter-rouge">account.xml</code>、<code class="highlighter-rouge">role.xml</code>、<code class="highlighter-rouge">AccountMapper.java</code>、<code class="highlighter-rouge">RoleMapper.java</code>、<code class="highlighter-rouge">AccountService.java</code>、<code class="highlighter-rouge">RoleService.java</code>、<code class="highlighter-rouge">Account.java</code> 以及 <code class="highlighter-rouge">Role.java</code>。<code class="highlighter-rouge">AccountMapper.java</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
public interface AccountMapper {
    public Account select(Object id);
    public Account selectOne(Account t);
    public Collection&lt;Account&gt; selectAll(Account t);
    public int count(Account t);
    public void insert(Account t);
    public int update(Account t);
    public int updatePersistent(Account t);
    public int delete(Account t);
}
</code></pre>
</div>
<p><code class="highlighter-rouge">RoleMapper.java</code> 如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
public interface RoleMapper {
    public Role select(Object id);
    public Role selectOne(Role t);
    public Collection&lt;Role&gt; selectAll(Role t);
    public int count(Role t);
    public void insert(Role t);
    public int update(Role t);
    public int updatePersistent(Role t);
    public int delete(Role t);
}
</code></pre>
</div>
<p><code class="highlighter-rouge">account.xml</code>、<code class="highlighter-rouge">role.xml</code>、<code class="highlighter-rouge">AccountService.java</code>、<code class="highlighter-rouge">RoleService.java</code>、<code class="highlighter-rouge">Account.java</code> 和 <code class="highlighter-rouge">Role.java</code> 与 <a href="http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E8%A7%A3%E5%86%B3pojo%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98">《使用 flying 解决 pojo 自动映射问题》</a> 中介绍的完全一致且不会在本文中进行修改，因此这里不再累述。</p>

<p>之后，我们再定义一个用于测试的数据集：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;dataset&gt;
    &lt;account account_id="1" fk_role_id="10" address="beijing" name="frank" /&gt;
    &lt;account account_id="2" fk_role_id="11" address="tianjin" name="gale" /&gt;
    &lt;account account_id="3" fk_role_id="11" address="beijing" name="hank" /&gt;
    &lt;role role_id="10" role_name="user" /&gt;
    &lt;role role_id="11" role_name="super_user" /&gt;
&lt;/dataset&gt;
</code></pre>
</div>
<p>当我们第一次执行 <code class="highlighter-rouge">accountService.select(1)</code> 时，会从数据库中得到一个 <code class="highlighter-rouge">name</code> 为 “frank” 的 Account 对象，当再次执行 <code class="highlighter-rouge">accountService.select(1)</code> 时，会不经数据库而从缓存中得到这个 Account 对象。如果我们通过数据库管理工具直接修改了这条记录，比如将 <code class="highlighter-rouge">name</code> 改为 “iris”，缓存也不会知道我们做出了改动，再次执行 <code class="highlighter-rouge">accountService.select(1)</code> 得到的 pojo 的 <code class="highlighter-rouge">name</code> 依然为 “frank”。但接下来如果我们在程序中执行 <code class="highlighter-rouge">accountService.update(account)</code> 将此对象的 <code class="highlighter-rouge">name</code> 改为 “hank”，则在数据库中的记录变更后缓存中的对象也会刷新，下一次再执行 <code class="highlighter-rouge">accountService.select(1)</code> 得到的 Account 对象的 <code class="highlighter-rouge">name</code> 就是 “hank” 了。</p>

<p>最后，我们强烈不建议在开启缓存的项目正在运行的情况下，通过数据库管理工具直接修改数据，这会导致数据库和缓存不一致，就像上一段中演示的那样。当您得到缓存的好处时，您也只能使用已经定义好的方法来操作数据库。（实际上，我们不建议通过数据库管理工具直接修改任何正在运行中的系统，无论它是否使用了缓存。）</p>
<h2 id="观察者--触发者"><a href="#Index">观察者 &amp; 触发者</a></h2>
<p>在上一节中我们了解了 mybatis 二级缓存的原理，但它本身还有需要优化的地方。例如当您缓存了一个 Account 对象后，当这个对象对应的 Role 对象发生改变时，我们当然希望缓存中的 Account 对象会知道它的多对一关系 Role 对象已经失效，然后在查询时会到数据库中查找最新数据（因为查询子对象时会自动加载父对象）。然而遗憾的是，mybatis 原始的二级缓存并没有这个功能，但是 flying 提供了解决方案。您只需将 flying 优化缓存的插件配置好并了解 “观察者” 和 “触发者” 的概念，就可以解决这一问题。</p>

<p>首先在 <code class="highlighter-rouge">Configuration.xml</code> 中的 <code class="highlighter-rouge">plugins</code> 中加入以下内容：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;plugins&gt;
    &lt;plugin interceptor="indi.mybatis.flying.interceptors.EnhancedCachingInterceptor"&gt;
        &lt;property name="cacheEnabled" value="true" /&gt;
        &lt;property name="annotationPackage" value="myPackage" /&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
</div>
<p>其中 <code class="highlighter-rouge">cacheEnabled</code> 为 <code class="highlighter-rouge">true</code> 表示让优化插件生效，<code class="highlighter-rouge">annotationPackage</code> 的值则是放置您所有 <i>pojo_mapper</i>.java 接口的包路径。如果您的 <i>pojo_mapper</i>.java 在多个包下（例如您在项目中用 mybatis 管理多个数据源，每个数据源的 <i>pojo_mapper</i>.java 放在不同的包内），这里可以配置多个包路径，只需用英文逗号分开即可，如 <code class="highlighter-rouge">value="myPackage,myPackage2"</code> 这样。如果您有未声明的 <i>pojo_mapper</i>.java，则该 pojo 对应的缓存不会被优化。</p>

<p>然后我们来介绍<b>观察者</b>和<b>触发者</b>的概念。在有父子关系的两个 pojo 中，父对象自身的改变可以使子对象的缓存失效，因此父对象可以称作子对象的<b>触发者</b>，而因为子对象只能参考它的父对象，子对象又可称为父对象的<b>观察者</b>。值得一提的是，这两种称呼都是基于 pojo 的关系的。所以会出现这种情况：pojo A 是 B 的触发者，pojo B 是 A 的观察者；同时 pojo B 是 C 的触发者，pojo C 是 B 的观察者。触发-观察关系可以传递，因此可以称 pojo A 是 C 的<b>间接触发者</b>，pojo C 是 A 的<b>间接观察者</b>。（如果两个 pojo 间有 触发-观察 关系但又不是直接关联，那就称为 间接触发-间接观察 关系，稍后您就后明白为什么要这么定义）。</p>

<p>接下来我们还需要了解触发者有哪些方法可以“触发”观察者，由之前的文章可以知道，<code class="highlighter-rouge">update</code>、<code class="highlighter-rouge">delete</code> 会使观察者改变，<code class="highlighter-rouge">select</code> 不会改变观察者，而 <code class="highlighter-rouge">insert</code> 是增加新的父对象，也不会改变观察者。了解以上概念后，我们就需要让程序了解我们的对象关系模型，而 flying 选择在 <i>pojo_mapper</i>.java 接口中接收您描述的对象关系模型。</p>

<p>我们只需在 AccountMapper.java 中增加一些注解：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import indi.mybatis.flying.annotations.CacheAnnotation;
import indi.mybatis.flying.annotations.CacheRoleAnnotation;
import indi.mybatis.flying.statics.CacheRoleType;

@CacheRoleAnnotation(ObserverClass = { Role.class }, TriggerClass = { Account.class })
public interface AccountMapper {

    @CacheAnnotation(role = CacheRoleType.Observer)
    public Account select(Object id);
    
    @CacheAnnotation(role = CacheRoleType.Observer)
    public Account selectOne(Account t);
    
    @CacheAnnotation(role = CacheRoleType.Observer)
    public Collection&lt;Account&gt; selectAll(Account t);
    
    @CacheAnnotation(role = CacheRoleType.Observer)
    public int count(Account t);
    
    public void insert(Account t);
    
    @CacheAnnotation(role = CacheRoleType.Trigger)
    public int update(Account t);
    
    @CacheAnnotation(role = CacheRoleType.Trigger)
    public int updatePersistent(Account t);
    
    @CacheAnnotation(role = CacheRoleType.Trigger)
    public int delete(Account t);
}
</code></pre>
</div>
<p>接下来我们对这些注解依次说明：
<code class="highlighter-rouge">@CacheRoleAnnotation</code> 只能放在类定义之上，它声明当前 <i>pojo_mapper</i>.java 接口对应的 pojo 和其它 pojo 的关系，具体来说，<code class="highlighter-rouge">ObserverClass</code> 描述的是当前 pojo 是哪些 pojo 的观察者，因此需要填写当前 pojo 的所有<b>直接触发者</b>的类名（无需填写间接触发者，因为 flying 在运行期可以推导出），<code class="highlighter-rouge">TriggerClass</code> 则<b>只需填写当前接口对应的 pojo 类名</b>。填好以后 <code class="highlighter-rouge">@CacheRoleAnnotation</code> 就配置完毕。</p>

<p><code class="highlighter-rouge">@CacheAnnotation</code> 只能放在方法定义之上，它声明当前这个方法是具有“触发”能力还是具有“观察”能力。具有触发能力的方法可以刷新这个类的观察者的缓存，具有观察能力的方法可以发现自己的缓存已被刷新，因为 触发－观察 关系可以传递，最终所有 pojo 的缓存关系都会被 flying 所获知。</p>

<p>在 flying 给定的方法中，<code class="highlighter-rouge">update</code>、<code class="highlighter-rouge">updatePersistent</code>、<code class="highlighter-rouge">delete</code> 具有触发能力，<code class="highlighter-rouge">select</code>、<code class="highlighter-rouge">selectOne</code>、<code class="highlighter-rouge">selectAll</code>、<code class="highlighter-rouge">count</code> 具有观察能力，所以要在相应的方法上配置 <code class="highlighter-rouge">@CacheRoleAnnotation</code> 注解。<code class="highlighter-rouge">insert</code> 既不具有触发能力也不具有观察能力。如果您在 <i>pojo_mapper</i>.java 中还有自己定义的方法，需要看这个方法对应的 sql 语句类型来进行配置，如果是 update 或 delete 类型就具有触发能力，如果是 select 类型就具有观察能力。</p>

<p>同样，RoleMapper.java 中也要增加一些注解：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>package myPackage;
import indi.mybatis.flying.annotations.CacheAnnotation;
import indi.mybatis.flying.annotations.CacheRoleAnnotation;
import indi.mybatis.flying.statics.CacheRoleType;

@CacheRoleAnnotation(ObserverClass = {}, TriggerClass = { Role.class })
public interface RoleMapper {

	@CacheAnnotation(role = CacheRoleType.Observer)
	public Role select(Object id);

	@CacheAnnotation(role = CacheRoleType.Observer)
	public Collection&lt;Role&gt; selectAll(Role t);

	@CacheAnnotation(role = CacheRoleType.Observer)
	public Role selectOne(Role t);

	@CacheAnnotation(role = CacheRoleType.Observer)
	public int count(Role t);

	public void insert(Role t);

	@CacheAnnotation(role = CacheRoleType.Trigger)
	public int update(Role t);

	@CacheAnnotation(role = CacheRoleType.Trigger)
	public int updatePersistent(Role t);

	@CacheAnnotation(role = CacheRoleType.Trigger)
	public int delete(Role t);
}
</code></pre>
</div>
<p>（如上可见，当前系统中 Role 对象已无父对象，也就是 Role 不是任何对象的观察者，因此它的 <code class="highlighter-rouge">@CacheRoleAnnotation</code> 中的 <code class="highlighter-rouge">ObserverClass</code> 为空，但在它的方法中，仍然建议将具有观察能力的方法上的注解写全，这样当您以后扩展项目需要为 Role 类时增加父对象时，只需要在 <code class="highlighter-rouge">@CacheRoleAnnotation</code> 中的 <code class="highlighter-rouge">ObserverClass</code> 上增加类名即可，不需要再修改方法上面的注解）</p>

<p>当您所有的 <i>pojo_mapper</i>.java 都按以上情况配置好后，flying 优化 mybatis 二级缓存的工作就完成了，现在您可以放心的使用 mybatis 的自带缓存，而不用担心任何缓存与数据库不匹配的问题。</p>

<h2 id="跨数据源缓存"><a href="#Index">跨数据源缓存</a></h2>
<p><code class="highlighter-rouge">最新版本新增</code> flying采用真实数据源配合自定义 TypeHandler 的方式来实现跨数据源，并可以将多个数据源的数据保存至同一缓存中，这一切都是自动完成的，您只需要给每个 <i>pojo_mapper</i>.java 都配置上合适的注解就能实现这一点，最终在缓存层面实现数据统一。</p>

<p>有一点需要注意的是，在跨数据源且使用二级缓存时，您在 <i>pojo_mapper</i>.xml 中的 resultMap 只能以 typeHandler 方式实现多对一，而不能以 association 方式。关于这一点，您可以阅读 <a href="http://flying-doc.limeng32.com/%E4%BD%BF%E7%94%A8flying%E8%A7%A3%E5%86%B3pojo%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98#%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90">《使用 flying 解决 pojo 自动映射问题》中的跨数据源</a> 部分。</p>

<h2 id="注意事项"><a href="#Index">注意事项</a></h2>

<h3 id="flying-如何判断缓存是否命中"><a href="#Index">flying 如何判断缓存是否命中</a></h3>
<p>flying 的缓存的 key 值是由查询条件 pojo 按业务属性序列化后再取 md5 生成，这样可保证不同线程上相同的查询条件 pojo 能够互相命中。因此使用缓存插件的前提条件是使用了<b>我们上一节介绍的 pojo 自动映射插件</b>，缓存插件无法单独使用。</p>

<h3 id="flying-已回滚的操作是否会生成缓存"><a href="#Index">flying 已回滚的操作是否会生成缓存</a></h3>
<p>不会生成。因为在您正确设计事务的情况下，未提交的（即被回滚）的数据变化是不会被查询到的，没有查询就不会生成缓存，所以您的缓存永远会和您的数据库保持一致，您可以放心的在有事务逻辑的系统中使用 flying 优化过的 mybatis 二级缓存。</p>

<h2 id="附录"><a href="#Index">附录</a></h2>
<p><a id="flying-demo2"></a></p>
<h3 id="代码示例"><a href="#Index">代码示例</a></h3>
<p><code class="highlighter-rouge">最新版本新增</code> 为了您更方便的使用 flying 进行优化 mybatis 二级缓存，我们提供了一个 <a href="https://github.com/limeng32/flying-demo2">跨数据源并使用二级缓存的代码示例</a> 供您查看。
<a id="AccountTableCreater"></a></p>
<h3 id="account-表建表语句"><a href="#Index">account 表建表语句</a></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>CREATE TABLE account (
  account_id int(11) NOT NULL AUTO_INCREMENT,
  name varchar(20) DEFAULT NULL,
  address varchar(100) DEFAULT NULL,
  fk_role_id int(11) DEFAULT NULL,
  fk_second_role_id int(11) DEFAULT NULL,
  PRIMARY KEY (account_id)
)
</code></pre>
</div>

<p><a id="RoleTableCreater"></a></p>
<h3 id="role-表建表语句"><a href="#Index">role 表建表语句</a></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>CREATE TABLE role (
  role_id int(11) NOT NULL AUTO_INCREMENT,
  role_name varchar(30) DEFAULT NULL,
  PRIMARY KEY (role_id)
)
</code></pre>
</div>
    </content>
  </entry>
  <entry>
    <title>flying的发展方向</title>
    <link href="http://flying-doc.limeng32.com/flying%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"/>
    <updated>2017-10-16T00:00:00+00:00</updated>
    <id>http://flying-doc.limeng32.com/flying%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91</id>
    <content type="html">
      <p>目前 flying 最新版本为 <code class="highlighter-rouge">0.7.3 、 0.8.1 、 0.9.1</code>，此版本新增特性：</p>

<ul>
  <li>对跨数据源调用的支持，为此在 <code class="highlighter-rouge">@FieldMapperAnnotation</code> 中新增了 <code class="highlighter-rouge">dbAssociationTypeHandler</code> 属性。</li>
  <li>强化了对 mybatis 自带二级缓存的改造，现在二级缓存可运行于多数据源环境，更加稳定，并可配合 redis 一起使用。</li>
</ul>

<p>下一版本预计新增对 mysql 之外的数据库的支持，并做到在多数据源下同时支持不同类型数据库，同时数据库查询中的 “或” 逻辑也会实现。新版本预计释出时间为春节期间。</p>

<p>flying 的代码在 github 上进行开源，访问地址为 <a href="https://github.com/limeng32/mybatis.flying">https://github.com/limeng32/mybatis.flying</a>，您可以在 github 上通过 Issues 与我们联系，提出您的需要，或是加入我们成为贡献者，提交您的代码，我们非常欢迎您这样做。我们的交流 QQ 群是：529363138 。</p>
    </content>
  </entry>
</feed>
